import * as XLSXUtils from 'xlsx-js-style';
import XLSXUtils__default from 'xlsx-js-style';
import { deepmerge } from 'deepmerge-ts';

const THIN_BORDER_STYLE = {
  top: { style: "thin", color: { rgb: "000000" } },
  left: { style: "thin", color: { rgb: "000000" } },
  right: { style: "thin", color: { rgb: "000000" } },
  bottom: { style: "thin", color: { rgb: "000000" } }
};
const THICK_BORDER_STYLE = {
  top: { style: "medium", color: { rgb: "000000" } },
  left: { style: "medium", color: { rgb: "000000" } },
  right: { style: "medium", color: { rgb: "000000" } },
  bottom: { style: "medium", color: { rgb: "000000" } }
};

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function getPropertyFromPath(obj, path) {
  try {
    return path.split(".").reduce((o, i) => o && o[i], obj);
  } catch (err) {
    return void 0;
  }
}
function getCellDataType(value) {
  if (value instanceof Date)
    return "d";
  if (typeof value === "number")
    return "n";
  if (typeof value === "boolean")
    return "b";
  return "s";
}
function buildSheetConfig(sheets) {
  return sheets.map((sheet) => ({
    sheet: sheet.sheetKey,
    params: sheet.params,
    tables: sheet.tables.map((table) => {
      const columns = table.schema.columns.filter((column) => {
        if (!column)
          return false;
        if (!table.select || Object.keys(table.select).length === 0)
          return true;
        const selectorMap = Object.entries(table.select).map(([key, value]) => ({ key, value }));
        if (selectorMap.every(({ value }) => value === false) && !selectorMap.some(({ key }) => key === column.columnKey))
          return true;
        if (selectorMap.some(({ key, value }) => key === column.columnKey && value === true))
          return true;
        return false;
      }).map((column) => {
        if (column.type === "column") {
          return column;
        } else {
          const builder = column.builder();
          column.handler(builder, (table.context ?? {})[column.columnKey]);
          const { columns: columns2 } = builder.build();
          return columns2;
        }
      }).flat().map((column) => {
        return {
          label: column?.label ?? column.columnKey,
          value: (row, index) => {
            const value = typeof column.key === "string" ? getPropertyFromPath(row, column.key) : column.key(row);
            if (typeof value === "undefined" || value === null || value === "" || Array.isArray(value) && value.length === 0 && column.default)
              return column.default;
            const transformedVal = column.transform ? column.transform(value, index) : value;
            return Array.isArray(transformedVal) && !transformedVal.length ? column.default ?? null : transformedVal;
          },
          _ref: column
        };
      });
      return {
        title: table.title,
        titleStyle: table.titleStyle,
        content: table.data,
        columns,
        enableSummary: table.summary ?? true,
        formatPresets: table.schema.formatPresets
      };
    })
  }));
}
function getColumnHeaderStyle(params) {
  return deepmerge(
    {
      font: { bold: true },
      alignment: { horizontal: "center", vertical: "center" },
      fill: { fgColor: { rgb: "E9E9E9" } },
      border: params?.bordered ?? true ? THICK_BORDER_STYLE : {}
    },
    params?.customStyle ?? {}
  );
}
function getWorksheetColumnWidths(worksheet, extraLength = 1) {
  const columnLetters = getWorksheetColumnIds(worksheet);
  return columnLetters.map((column) => {
    const columnCells = Object.keys(worksheet).filter((cell) => cell.replace(/[0-9]/g, "") === column);
    const maxWidthCell = columnCells.reduce((maxWidth, cellId) => {
      const cell = worksheet[cellId];
      const cellContentLength = getCellValueLength(cell.v);
      if (!cell.z)
        return Math.max(maxWidth, cellContentLength);
      const cellFormatLength = cell.z.length;
      const largestWidth = Math.max(cellContentLength, cellFormatLength);
      return Math.max(maxWidth, largestWidth);
    }, 0);
    return { wch: maxWidthCell + extraLength };
  });
}
function getCellValueLength(object) {
  if (typeof object === "string")
    return Math.max(...object.split("\n").map((string) => string.length));
  if (typeof object === "number")
    return object.toString().length;
  if (typeof object === "boolean")
    return object ? "true".length : "false".length;
  if (object instanceof Date)
    return object.toString().length;
  return 0;
}
function getWorksheetColumnIds(worksheet) {
  const columnRange = XLSXUtils.utils.decode_range(worksheet["!ref"] ?? "");
  const columnIds = [];
  for (let C = columnRange.s.c; C <= columnRange.e.c; C++) {
    const address = XLSXUtils.utils.encode_col(C);
    columnIds.push(address);
  }
  return columnIds;
}
function splitIntoChunks(array, chunkSize) {
  if (!chunkSize)
    return [array];
  const chunks = [];
  for (let i = 0; i < array.length; i += chunkSize)
    chunks.push(array.slice(i, i + chunkSize));
  return chunks;
}
function getSheetChunkMaxHeight(tables) {
  return tables.reduce((acc, table) => {
    const hasTitle = !!table.title;
    const summaryRowLength = tableSummaryRowLength(table);
    const maxRowSpan = table.content.reduce((max, row, rowIndex) => {
      return Math.max(max, ...table.columns.map((column) => {
        const values = column.value(row, rowIndex);
        return Array.isArray(values) ? values.length : 1;
      }));
    }, 1);
    const tableHeight = table.content.length * maxRowSpan + 1 + summaryRowLength + (hasTitle ? 1 : 0);
    return Math.max(acc, tableHeight);
  }, 0);
}
function tableHasSummary(table) {
  return table.enableSummary && table.columns.some((column) => column._ref?.summary?.length);
}
function tableSummaryRowLength(table) {
  return table.columns.reduce((acc, column) => {
    const columnSummaryLength = column._ref?.summary?.length ?? 0;
    return Math.max(acc, columnSummaryLength);
  }, 0);
}
function applyGroupBorders(worksheet, params) {
  const start = XLSXUtils.utils.decode_cell(params.start);
  const end = XLSXUtils.utils.decode_cell(params.end);
  for (let r = start.r; r <= end.r; r++) {
    for (let c = start.c; c <= end.c; c++) {
      const cellRef = XLSXUtils.utils.encode_cell({ c, r });
      const cell = worksheet[cellRef] || { t: "z" };
      cell.s = deepmerge(cell.s ?? {}, {
        border: {
          ...cell.s?.border ?? {}
        }
      });
      if (r === start.r)
        cell.s.border.top = THICK_BORDER_STYLE.top;
      if (r === end.r)
        cell.s.border.bottom = THICK_BORDER_STYLE.bottom;
      if (c === start.c)
        cell.s.border.left = THICK_BORDER_STYLE.left;
      if (c === end.c)
        cell.s.border.right = THICK_BORDER_STYLE.right;
      worksheet[cellRef] = cell;
    }
  }
}
function getRowMaxHeight(params) {
  return params.tableConfig.columns.reduce((acc, column) => {
    const row = params.tableConfig.content[params.rowIndex];
    const _resolvedValue = column.value(row, params.rowIndex);
    const values = Array.isArray(_resolvedValue) ? _resolvedValue : [_resolvedValue];
    return Math.max(acc, values.length);
  }, 1);
}
function getCellValue(params) {
  const _resolvedValue = params.value(params.row, params.rowIndex);
  return Array.isArray(_resolvedValue) ? _resolvedValue : [_resolvedValue];
}
function getColumnSeparatorIndexes(params) {
  return params.sheetConfig.tables.map((table, index) => {
    if (index === params.sheetConfig.tables.length - 1)
      return [];
    const tableConfig = params.sheetConfig.tables[index];
    const colsCount = tableConfig.columns.length;
    return Array.from({ length: params.offset }, (_, i) => colsCount + i);
  }).flat();
}
function createCell(params) {
  const style = typeof params.style === "function" ? params.style(params.data ?? {}, params?.rowIndex ?? 0, params?.subRowIndex ?? 0) : params.style ?? {};
  const rawFormat = typeof params.format === "function" ? params.format(params.data ?? {}, params?.rowIndex ?? 0, params?.subRowIndex ?? 0) : params.format;
  const format = typeof rawFormat === "string" ? rawFormat : rawFormat?.preset ? params.formatPresets[rawFormat.preset] ? typeof params.formatPresets[rawFormat.preset] === "function" ? params.formatPresets[rawFormat.preset](rawFormat.params) : params.formatPresets[rawFormat.preset] : "" : rawFormat;
  return {
    v: params.value === null ? "" : params.value,
    t: getCellDataType(params.value),
    z: format,
    s: deepmerge({
      border: params.bordered ?? true ? THIN_BORDER_STYLE : {},
      alignment: { vertical: "center" },
      numFmt: format
    }, style, params.extraStyle ?? {})
  };
}
class TableCacheManager {
  constructor(table) {
    __publicField$1(this, "table");
    __publicField$1(this, "rows");
    __publicField$1(this, "rowMaxHeight", /* @__PURE__ */ new Map());
    __publicField$1(this, "prevRowsHeight", /* @__PURE__ */ new Map());
    __publicField$1(this, "cellValue", /* @__PURE__ */ new Map());
    __publicField$1(this, "nbExtraRows", 0);
    this.table = table;
    this.rows = table.content;
    table.content.forEach((row, rowIndex) => {
      const rowHeight = getRowMaxHeight({ tableConfig: this.table, rowIndex });
      const _prevRowsHeight = (this.getPrevRowsHeight(rowIndex - 1) ?? 0) + (this.getRowMaxHeight(rowIndex - 1) ?? 0);
      this.rowMaxHeight.set(rowIndex, rowHeight);
      this.prevRowsHeight.set(rowIndex, _prevRowsHeight);
      table.columns.forEach((column, columnIndex) => {
        const cellValue = getCellValue({ row, rowIndex, value: column.value });
        this.cellValue.set(`${columnIndex}:${rowIndex}`, cellValue);
      });
    });
    this.nbExtraRows = table.columns.reduce((acc, _, columnIndex) => {
      return Math.max(acc, table.content.reduce((acc2, _2, rowIndex) => {
        const values = this.getCellValue({ columnIndex, rowIndex });
        return values.length - 1 + acc2;
      }, 0));
    }, 0);
  }
  getTableHeight() {
    return Array.from(this.rowMaxHeight.values()).reduce((acc, rowHeight) => acc + rowHeight, 0);
  }
  getPrevRowsHeight(rowIndex) {
    return this.prevRowsHeight.get(rowIndex) ?? 0;
  }
  getRowMaxHeight(rowIndex) {
    return this.rowMaxHeight.get(rowIndex) ?? 0;
  }
  getCellValue({ columnIndex, rowIndex }) {
    return this.cellValue.get(`${columnIndex}:${rowIndex}`) ?? [];
  }
  getNbExtraRows() {
    return this.nbExtraRows;
  }
}
function getSheetWidth(sheetRows) {
  return sheetRows.reduce((acc, tables) => {
    const rowWidth = tables.reduce((acc2, table) => {
      const tableWidth = table.columns.length;
      return acc2 + tableWidth + 1;
    }, 0);
    return Math.max(acc, rowWidth);
  }, 0);
}
function getSheetHeight(sheetChunks, tableCaches) {
  return sheetChunks.reduce((acc, tables) => {
    const chunkHeight = tables.reduce((acc2, _, tableIndex) => {
      const { table, cache } = tableCaches.get(tableIndex);
      const hasTitle = !!table.title;
      const summaryRowLength = tableSummaryRowLength(table);
      const maxRowSpan = table.columns.reduce((max, _2, columnIndex) => {
        return Math.max(max, table.content.reduce((maxRow, _3, rowIndex) => {
          const values = cache.getCellValue({ columnIndex, rowIndex });
          return Array.isArray(values) ? Math.max(maxRow, values.length) : maxRow;
        }, 1));
      }, 1);
      const tableHeight = table.content.length * maxRowSpan + summaryRowLength + (hasTitle ? 1 : 0);
      return Math.max(acc2, tableHeight);
    }, 0);
    return acc + chunkHeight + 1;
  }, 0);
}
function getSheetRange(params) {
  return XLSXUtils.utils.encode_range({ s: { c: 0, r: 0 }, e: { c: params.width - 1, r: params.height - 1 } });
}
class SheetCacheManager {
  constructor(sheets) {
    __publicField$1(this, "computedSheets", /* @__PURE__ */ new Map());
    sheets.forEach((sheet, sheetIndex) => {
      const chunks = splitIntoChunks(sheet.tables, sheet.params?.tablesPerRow);
      const tables = /* @__PURE__ */ new Map();
      sheet.tables.forEach((table, tableIndex) => tables.set(tableIndex, { table, cache: new TableCacheManager(table) }));
      const width = getSheetWidth(chunks);
      const height = getSheetHeight(chunks, tables);
      const range = getSheetRange({ width, height });
      this.computedSheets.set(sheetIndex, {
        sheet,
        tables,
        chunks: chunks.map((tables2, chunkIndex) => ({
          tables: tables2.map((_, tableIndex) => tableIndex + chunkIndex * (sheet.params?.tablesPerRow ?? 1)),
          maxHeight: getSheetChunkMaxHeight(tables2),
          hasTitle: tables2.some((table) => !!table.title)
        })),
        range: { height, width, range }
      });
    });
  }
  getSheets() {
    return Array.from(this.computedSheets.values());
  }
  getSheetChunk(params) {
    return this.computedSheets.get(params.sheetIndex)?.chunks[params.chunkIndex];
  }
  getSheetTable(params) {
    return this.computedSheets.get(params.sheetIndex).tables.get(params.tableIndex);
  }
  getSheetRange(params) {
    return this.computedSheets.get(params.sheetIndex).range;
  }
  getTableRange(params) {
    const sheet = this.computedSheets.get(params.sheetIndex);
    const { table, cache } = sheet.tables.get(params.tableIndex);
    const { colOffset, rowOffset } = params;
    return utils.encode_range({
      s: {
        c: colOffset,
        r: rowOffset
      },
      e: {
        c: colOffset + table.columns.length - 1,
        r: rowOffset + cache.getTableHeight()
      }
    });
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ExcelSchemaBuilder {
  constructor() {
    __publicField(this, "columns", []);
    __publicField(this, "transformers", {});
    __publicField(this, "formatters", {});
  }
  static create() {
    return new ExcelSchemaBuilder();
  }
  withTransformers(transformers) {
    this.transformers = transformers;
    return this;
  }
  withFormatters(formatters) {
    this.formatters = formatters;
    return this;
  }
  column(columnKey, column) {
    if (this.columns.some((c) => c.columnKey === columnKey))
      throw new Error(`Column with key '${columnKey}' already exists.`);
    this.columns.push({ type: "column", columnKey, ...column });
    return this;
  }
  group(key, handler) {
    if (this.columns.some((c) => c.columnKey === key))
      throw new Error(`Column with key '${key}' already exists.`);
    const builder = () => ExcelSchemaBuilder.create().withTransformers(this.transformers).withFormatters(this.formatters);
    this.columns.push({
      type: "group",
      columnKey: key,
      builder,
      handler
    });
    return this;
  }
  build() {
    const columns = this.columns.map((column) => column.type === "column" ? {
      ...column,
      transform: typeof column.transform === "string" ? this.transformers[column.transform] : column.transform
    } : column);
    return {
      columns,
      formatPresets: this.formatters
    };
  }
}
class ExcelBuilder {
  constructor() {
    __publicField(this, "sheets", []);
  }
  static create() {
    return new ExcelBuilder();
  }
  sheet(key, params) {
    if (this.sheets.some((s) => s.sheetKey === key))
      throw new Error(`Sheet with key '${key}' already exists.`);
    this.sheets.push({ sheetKey: key, params: params ?? {}, tables: [] });
    return {
      addTable: (table) => this.defineTable(key, table),
      sheet: (key2) => this.sheet(key2),
      build: (params2) => this.build(params2)
    };
  }
  defineTable(key, table) {
    const sheet = this.sheets.find((s) => s.sheetKey === key);
    if (!sheet)
      throw new Error(`Sheet with key '${key}' does not exist.`);
    sheet.tables.push(table);
    return {
      addTable: (newTable) => this.defineTable(key, newTable),
      sheet: (key2, params) => this.sheet(key2, params),
      build: (params) => this.build(params)
    };
  }
  build(params) {
    var _a;
    const workbook = XLSXUtils.utils.book_new();
    const sheetsConfig = buildSheetConfig(this.sheets);
    const sheetCacheManager = new SheetCacheManager(sheetsConfig);
    const TABLE_CELL_OFFSET = 1;
    sheetCacheManager.getSheets().forEach((sheetConfig, sheetIndex) => {
      const tableChunks = sheetConfig.chunks;
      const worksheet = {
        "!merges": []
      };
      let COL_OFFSET = 0;
      let ROW_OFFSET = 0;
      const titleRowIndexes = [];
      tableChunks.forEach((chunk, chunkIndex) => {
        COL_OFFSET = 0;
        if (chunkIndex > 0)
          ROW_OFFSET += TABLE_CELL_OFFSET + (chunkIndex > 0 ? sheetCacheManager.getSheetChunk({ sheetIndex, chunkIndex })?.maxHeight ?? 0 : 0);
        if (chunk.hasTitle)
          titleRowIndexes.push(ROW_OFFSET);
        chunk.tables.forEach((tableIndex) => {
          const { cache: tableCache, table: tableConfig } = sheetCacheManager.getSheetTable({ sheetIndex, tableIndex });
          if (tableIndex > 0) {
            const prevTable = sheetCacheManager.getSheetTable({ sheetIndex, tableIndex: tableIndex - 1 }).table;
            COL_OFFSET += prevTable.columns.length + TABLE_CELL_OFFSET;
          }
          const hasTitle = !!tableConfig.title;
          if (hasTitle) {
            const titleStyle = typeof tableConfig.titleStyle === "function" ? tableConfig.titleStyle(tableConfig.content) : tableConfig.titleStyle ?? {};
            tableConfig.columns.forEach((_, colIndex) => {
              const titleCellRef = XLSXUtils.utils.encode_cell({ c: COL_OFFSET + colIndex, r: ROW_OFFSET });
              worksheet[titleCellRef] = createCell({
                value: colIndex === 0 ? tableConfig.title : "",
                style: getColumnHeaderStyle({ bordered: params?.bordered ?? true, customStyle: titleStyle }),
                extraStyle: {
                  alignment: { horizontal: "left" },
                  fill: { fgColor: { rgb: "b4c4de" } },
                  font: { sz: 20 }
                },
                formatPresets: tableConfig.formatPresets
              });
            });
            worksheet["!merges"].push({
              s: { c: COL_OFFSET, r: ROW_OFFSET },
              e: { c: COL_OFFSET + tableConfig.columns.length - 1, r: ROW_OFFSET }
            });
          }
          tableConfig.columns.forEach((column, colIndex) => {
            const headerCellRef = XLSXUtils.utils.encode_cell({ c: colIndex + COL_OFFSET, r: ROW_OFFSET + (chunk.hasTitle ? 1 : 0) });
            worksheet[headerCellRef] = createCell({
              value: column.label,
              bordered: params?.bordered ?? true,
              style: getColumnHeaderStyle({ bordered: params?.bordered ?? true, customStyle: column._ref.headerStyle }),
              formatPresets: tableConfig.formatPresets
            });
            tableConfig.content.forEach((row, rowIndex) => {
              const maxRowHeight = tableCache.getRowMaxHeight(rowIndex);
              const prevRowHeight = tableCache.getPrevRowsHeight(rowIndex);
              const values = tableCache.getCellValue({ columnIndex: colIndex, rowIndex });
              values.forEach((value, valueIndex) => {
                const cellRef = XLSXUtils.utils.encode_cell({
                  c: colIndex + COL_OFFSET,
                  r: prevRowHeight + ROW_OFFSET + (chunk.hasTitle ? 1 : 0) + (valueIndex + 1)
                });
                worksheet[cellRef] = createCell({
                  value,
                  data: row,
                  format: column._ref.format,
                  style: column._ref.cellStyle,
                  bordered: params?.bordered ?? true,
                  rowIndex,
                  subRowIndex: valueIndex,
                  formatPresets: tableConfig.formatPresets
                });
              });
              if (values.length < maxRowHeight && maxRowHeight > 1) {
                for (let valueIndex = values.length; valueIndex < maxRowHeight; valueIndex++) {
                  const cellRef = XLSXUtils.utils.encode_cell({
                    c: colIndex + COL_OFFSET,
                    r: prevRowHeight + ROW_OFFSET + (chunk.hasTitle ? 1 : 0) + (valueIndex + 1)
                  });
                  worksheet[cellRef] = createCell({ value: "", bordered: params?.bordered ?? true, formatPresets: tableConfig.formatPresets });
                }
                if (values.length === 1) {
                  worksheet["!merges"].push({
                    s: { c: colIndex + COL_OFFSET, r: prevRowHeight + 1 + ROW_OFFSET + (chunk.hasTitle ? 1 : 0) },
                    e: { c: colIndex + COL_OFFSET, r: prevRowHeight + 1 + ROW_OFFSET + (chunk.hasTitle ? 1 : 0) + maxRowHeight - 1 }
                  });
                }
              }
            });
            if (tableHasSummary(tableConfig)) {
              const summaryRowIndex = tableConfig.content.length + 1 + tableCache.getNbExtraRows();
              for (const summaryIndex in column._ref?.summary ?? []) {
                const summary = column._ref?.summary?.[summaryIndex];
                const cellRef = XLSXUtils.utils.encode_cell({
                  c: +colIndex + COL_OFFSET,
                  r: summaryRowIndex + ROW_OFFSET + +summaryIndex + (chunk.hasTitle ? 1 : 0)
                });
                if (!summary) {
                  worksheet[cellRef] = createCell({
                    value: "",
                    bordered: params?.bordered ?? true,
                    style: getColumnHeaderStyle({ bordered: params?.bordered ?? true }),
                    formatPresets: tableConfig.formatPresets
                  });
                  continue;
                }
                const value = summary.value(tableConfig.content);
                worksheet[cellRef] = createCell({
                  value,
                  data: tableConfig.content,
                  format: summary.format,
                  style: summary.cellStyle,
                  bordered: params?.bordered ?? true,
                  extraStyle: {
                    font: { bold: true },
                    fill: { fgColor: { rgb: "E9E9E9" } },
                    alignment: { vertical: "center" }
                  },
                  formatPresets: tableConfig.formatPresets
                });
              }
            }
          });
          if (tableCache.getNbExtraRows() > 0) {
            tableConfig.content.forEach((row, rowIndex) => {
              const prevRowHeight = tableCache.getPrevRowsHeight(rowIndex);
              const rowStart = prevRowHeight + 1 + ROW_OFFSET + (chunk.hasTitle ? 1 : 0);
              const currentRowHeight = tableCache.getRowMaxHeight(rowIndex);
              const start = XLSXUtils.utils.encode_cell({ c: COL_OFFSET, r: rowStart });
              const end = XLSXUtils.utils.encode_cell({ c: COL_OFFSET + tableConfig.columns.length - 1, r: rowStart + (currentRowHeight - 1) });
              applyGroupBorders(worksheet, { start, end });
            });
          }
        });
      });
      const { height: sheetHeight, range: sheetRange } = sheetCacheManager.getSheetRange({ sheetIndex });
      const colSeparatorIndexes = getColumnSeparatorIndexes({ sheetConfig: sheetConfig.sheet, offset: TABLE_CELL_OFFSET });
      worksheet["!ref"] = sheetRange;
      worksheet["!rows"] = Array.from(
        { length: sheetHeight },
        (_, index) => ({ hpt: titleRowIndexes.includes(index) ? 40 : params?.rowHeight ?? 30 })
      );
      worksheet["!cols"] = getWorksheetColumnWidths(worksheet, params?.extraLength ?? 5).map(({ wch }, index) => ({ wch: colSeparatorIndexes.includes(index) ? sheetConfig.sheet.params?.tableSeparatorWidth ?? 25 : wch }));
      XLSXUtils.utils.book_append_sheet(workbook, worksheet, sheetConfig.sheet.sheet);
    });
    workbook.Workbook ?? (workbook.Workbook = {});
    (_a = workbook.Workbook).Views ?? (_a.Views = [{}]);
    workbook.Workbook.Views.forEach((view) => view.RTL = params?.rtl ?? false);
    return params.output === "workbook" ? workbook : XLSXUtils__default.write(workbook, { type: params.output, bookType: "xlsx" });
  }
}

export { ExcelBuilder, ExcelSchemaBuilder };
