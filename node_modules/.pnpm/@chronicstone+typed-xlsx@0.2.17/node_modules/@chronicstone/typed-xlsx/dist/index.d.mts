import { Buffer, File } from 'node:buffer';
import XLSX, { CellStyle } from 'xlsx-js-style';

type GenericObject = Record<string | number | symbol, any>;
type NestedPaths<T> = T extends Array<infer U> ? U extends (object | Date) ? never : never : T extends Date ? never : T extends object ? {
    [K in keyof T & (string | number)]: K extends string ? `${K}` | (NonNullable<T[K]> extends object ? `${K}.${NestedPaths<NonNullable<T[K]>>}` : never) : never;
}[keyof T & (string | number)] : never;
type Not<T, U> = T extends U ? never : T;
type IfExistsInAllUnionMembers<T, K extends PropertyKey> = T extends any ? K extends keyof T ? true : false : never;
type TypeFromPath<T, Path extends string> = T extends any ? (Path extends keyof T ? T[Path] : Path extends `${infer P}.${infer R}` ? P extends keyof T ? T[P] extends GenericObject | null | undefined ? TypeFromPath<Exclude<T[P], undefined | null>, R> : never : never : never) : never;
type TypeFromPathUnion<T, Path extends string> = IfExistsInAllUnionMembers<T, Path> extends true ? TypeFromPath<T, Path> : TypeFromPath<T, Path> | undefined;
type AllKeysMatch<T extends object, U> = {
    [K in keyof T]: T[K] extends U ? true : false;
}[keyof T] extends true ? true : false;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
type BaseCellValue = string | number | boolean | null | undefined | Date;
type CellValue = BaseCellValue | BaseCellValue[];
type ValueTransformer = (value: any, index: number) => CellValue;
interface TransformersMap {
    [key: string]: ValueTransformer;
}
type FormatterFunction = (params: any) => string;
interface FormattersMap {
    [key: string]: FormatterFunction | string;
}
type FormatterPreset<T extends FormattersMap> = {
    [Key in keyof T]: ({
        preset: Key;
    } & (T[Key] extends infer P ? P extends (params: any) => any ? {
        params: Parameters<P>[0];
    } : {} : {}));
};
type NonNullableDeep<T> = T extends null | undefined ? never : T;
type DeepRequired<T> = {
    [P in keyof T]-?: DeepRequired<NonNullableDeep<T[P]>>;
};
type TypedTransformersMap<TransformMap extends TransformersMap, Value> = {
    [K in keyof TransformMap]: Value extends Parameters<TransformMap[K]>[0] ? K : never;
}[keyof TransformMap];
type ExtractColumnValue<T extends GenericObject, FieldValue extends string | ((data: T) => CellValue)> = FieldValue extends string ? TypeFromPathUnion<T, FieldValue> : FieldValue extends (...args: any[]) => any ? ReturnType<FieldValue> : never;
type Column<T extends GenericObject, FieldValue extends string | ((data: T) => CellValue), ColKey extends string, TransformMap extends TransformersMap, FormatMap extends FormattersMap, Preset extends FormatterPreset<FormatMap>[keyof FormatMap] = never> = {
    type: 'column';
    label?: string;
    columnKey: ColKey;
    key: FieldValue;
    default?: CellValue;
    format?: Preset | string | ((rowData: T, rowIndex: number, subRowIndex: number) => string | Preset);
    cellStyle?: CellStyle | ((rowData: T, rowIndex: number, subRowIndex: number) => CellStyle);
    headerStyle?: CellStyle;
    summary?: Array<{
        value: (data: T[]) => BaseCellValue;
        format?: string | Preset | ((data: T[]) => string | Preset);
        cellStyle?: CellStyle | ((data: T[]) => CellStyle);
    }>;
} & (ExtractColumnValue<T, FieldValue> extends CellValue ? {
    transform?: TypedTransformersMap<TransformMap, ExtractColumnValue<T, FieldValue>> | ((value: ExtractColumnValue<T, FieldValue>, index: number) => CellValue);
} : {
    transform: TypedTransformersMap<TransformMap, ExtractColumnValue<T, FieldValue>> | ((value: ExtractColumnValue<T, FieldValue>, index: number) => CellValue);
});
interface ColumnGroup<T extends GenericObject, ColKey extends string, KeyPaths extends string, UsedKeys extends string, TransformMap extends TransformersMap, FormatMap extends FormattersMap, Context, ContextMap extends Record<string, any> = {}> {
    type: 'group';
    columnKey: ColKey;
    builder: () => ExcelSchemaBuilder<T, KeyPaths, UsedKeys, TransformMap, FormatMap>;
    handler: GroupHandler<T, KeyPaths, UsedKeys, TransformMap, FormatMap, Context>;
}
type GroupHandler<T extends GenericObject, CellKeyPaths extends string, UsedKeys extends string, TransformMap extends TransformersMap, FormatMap extends FormattersMap, Context> = (builder: ExcelSchemaBuilder<T, CellKeyPaths, UsedKeys, TransformMap, FormatMap>, context: Context) => void;
interface ExcelSchema<T extends GenericObject, KeyPaths extends string, Key extends string, ContextMap extends {
    [key: string]: any;
} = {}> {
    columns: Array<Column<T, KeyPaths, Key, any, any> | ColumnGroup<T, Key, KeyPaths, string, any, any, any>>;
    formatPresets: FormattersMap;
}
type SchemaColumnKeys<T extends ExcelSchema<any, any, string>> = T['columns'] extends Array<Column<any, any, infer K, any, any> | ColumnGroup<any, infer K, any, any, any, any, any>> ? K : never;
type SheetTable<T extends GenericObject, Schema extends ExcelSchema<T, any, string, any>, ColumnKeys extends SchemaColumnKeys<Schema>, SelectColsMap extends {
    [key in ColumnKeys]?: boolean;
} | never, SelectedCols extends string = ExtractSelectedColumns<ColumnKeys, SelectColsMap>, ContextMap extends {
    [key: string]: any;
} = ExtractContextMap<Schema>, SelectedContextMap extends ExtractSelectedContext<ContextMap, SelectedCols> = ExtractSelectedContext<ContextMap, SelectedCols>> = {
    title?: string;
    titleStyle?: CellStyle | ((data: T[]) => CellStyle);
    schema: Schema;
    data: T[];
    select?: SelectColsMap;
    context?: {};
    summary?: boolean;
} & (keyof SelectedContextMap extends never ? {} : {
    context: Prettify<SelectedContextMap>;
});
interface SheetTableBuilder<Builder extends ExcelBuilder<any>, UsedKeys extends string> {
    addTable: <T extends GenericObject, Schema extends ExcelSchema<T, any, string>, ColKeys extends SchemaColumnKeys<Schema>, SelectCols extends {
        [key in ColKeys]?: boolean;
    } = {}>(table: SheetTable<T, Schema, ColKeys, SelectCols>) => SheetTableBuilder<Builder, UsedKeys>;
    sheet: Builder['sheet'];
    build: Builder['build'];
}
interface SheetParams {
    tableSeparatorWidth?: number;
    tablesPerRow?: number;
}
interface SheetConfig {
    sheetKey: string;
    params: SheetParams;
    tables: Array<SheetTable<GenericObject, ExcelSchema<any, any, any, any>, any, any, any, any, any>>;
}
type ExtractContextMap<Schema extends ExcelSchema<any, any, string, any>> = Schema extends ExcelSchema<any, any, any, infer Ctx> ? Ctx : {};
type ExtractSelectedColumns<ColKeys extends string, SelectCols extends {
    [key in ColKeys]?: boolean;
}> = keyof SelectCols extends never ? ColKeys : AllKeysMatch<SelectCols, false> extends true ? Exclude<ColKeys, keyof SelectCols> : {
    [K in ColKeys]: SelectCols[K] extends true ? K : never;
}[ColKeys];
type ExtractSelectedContext<ContextMap extends {
    [key: string]: any;
}, SelectedCols extends string> = {
    [K in keyof ContextMap as K extends SelectedCols ? K : never]: ContextMap[K];
};
type TOutputType = 'buffer' | 'workbook' | 'base64' | 'file';
interface ExcelBuildParams<Output extends TOutputType> {
    output: Output;
    rtl?: boolean;
    extraLength?: number;
    rowHeight?: number;
    bordered?: boolean;
}
type ExcelBuildOutput<Output extends TOutputType> = Output extends 'workbook' ? XLSX.WorkBook : Output extends 'base64' ? string : Output extends 'buffer' ? Buffer : Output extends 'file' ? File : never;
type MakeRequired<T, K extends keyof T> = Prettify<Omit<T, K> & Required<Pick<T, K>>>;

declare class ExcelSchemaBuilder<T extends GenericObject, CellKeyPaths extends string, UsedKeys extends string = never, TransformMap extends TransformersMap = {}, FormatMap extends FormattersMap = {}, ContextMap extends {
    [key: string]: any;
} = {}> {
    private columns;
    private transformers;
    private formatters;
    static create<T extends GenericObject, KeyPath extends string = NestedPaths<T>>(): ExcelSchemaBuilder<T, KeyPath>;
    withTransformers<Transformers extends TransformersMap>(transformers: Transformers): ExcelSchemaBuilder<T, CellKeyPaths, UsedKeys, TransformMap & Transformers, FormatMap, ContextMap>;
    withFormatters<Formatters extends FormattersMap>(formatters: Formatters): ExcelSchemaBuilder<T, CellKeyPaths, UsedKeys, TransformMap, FormatMap & Formatters, ContextMap>;
    column<K extends string, FieldValue extends CellKeyPaths | ((data: T) => CellValue), Preset extends FormatterPreset<FormatMap>[keyof FormatMap]>(columnKey: Not<K, UsedKeys>, column: Omit<Column<T, FieldValue, K, TransformMap, FormatMap, Preset>, 'columnKey' | 'type'>): ExcelSchemaBuilder<T, CellKeyPaths, UsedKeys | K, TransformMap, FormatMap, ContextMap>;
    group<K extends `group:${string}`, Context>(key: Not<K, UsedKeys>, handler: (builder: ExcelSchemaBuilder<T, CellKeyPaths, never, TransformMap, FormatMap>, context: Context) => void): ExcelSchemaBuilder<T, CellKeyPaths, UsedKeys | K, TransformMap, FormatMap, ContextMap & {
        [key in K]: Context;
    }>;
    build(): ExcelSchema<T, CellKeyPaths, UsedKeys, ContextMap>;
}
declare class ExcelBuilder<UsedSheetKeys extends string = never> {
    private sheets;
    static create(): ExcelBuilder;
    sheet<Key extends string>(key: Not<Key, UsedSheetKeys>, params?: SheetParams): SheetTableBuilder<ExcelBuilder<UsedSheetKeys | Key>, UsedSheetKeys | Key>;
    private defineTable;
    build<OutputType extends TOutputType, Output = ExcelBuildOutput<OutputType>>(params: ExcelBuildParams<OutputType>): Output;
}

export { type AllKeysMatch, type BaseCellValue, type CellValue, type Column, type ColumnGroup, type DeepRequired, type ExcelBuildOutput, type ExcelBuildParams, ExcelBuilder, type ExcelSchema, ExcelSchemaBuilder, type ExtractColumnValue, type ExtractContextMap, type ExtractSelectedColumns, type ExtractSelectedContext, type FormatterFunction, type FormatterPreset, type FormattersMap, type GenericObject, type GroupHandler, type MakeRequired, type NestedPaths, type NonNullableDeep, type Not, type Prettify, type SchemaColumnKeys, type SheetConfig, type SheetParams, type SheetTable, type SheetTableBuilder, type TOutputType, type TransformersMap, type TypeFromPath, type TypeFromPathUnion, type TypedTransformersMap, type ValueTransformer };
